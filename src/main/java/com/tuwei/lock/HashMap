JDK1.7是数组+链表  Entry类
JDK1.8是数组+链表+红黑树 Node类
JDK1.8对于JDK1.7引入了红黑树原因是为了提高HashMap性能
解决发生哈希碰撞后链表过长从而导致索引效率慢的问题
无哈希冲突时，数据存数组
冲突&链表长度小于8，数据存链表
冲突&链表长度大于8，数据存红黑树

存储过程
1.接收需要存储的键值对kv
2.根据传入的key计算hash值
3.判断是否发生hash冲突
4.如果没发生hash冲突，将键值对存储到数组相应的位置
5.如果发生hash冲突，判断当前节点数据结构是红黑树还是链表
6.如果是红黑树就在红黑树中插入数据，如果是链表就在链表中插入数据

容量
必须是2的幂次方，且小于2的30次方，默认16，如果传入的超过最大则为最大值
加载因子
默认0.75，衡量hashMap是否需要自动扩容的尺度
1.加载因子越大
填的元素越多，空间利用率越高
冲突的概率越大，链表越长，查询的效率越低
2.加载因子越小
冲突概率小，链表短，查询效率高
填的元素少，频繁进行扩容操作，扩容比较消耗性能

扩容阈值
容量X加载因子，当前哈希表的大小超过了扩容阈值，则会自动扩容，

桶的树化阈值
默认8，链表转红黑树的阈值
桶的链表还原阈值
默认6，红黑树转为链表的阈值
最小树形化阈值
默认64，当哈希表中的容量大于该值时，才允许将链表转为红黑树

tableSizeFor(int cap)将传入的容量转换为大于等于cap的2的幂次方

hashcode的计算方式
2次扰动=1次位运算+1次异或运算
1.8选择尾插法，直接插入链表/红黑树尾部
1.7选择头插法，先将原来位置的数移动到后一位，再插入数据到这个位置




红黑数是一种特殊的二叉树，父子节点必须是不同颜色的，非黑即红
实现LinkedHashMap

